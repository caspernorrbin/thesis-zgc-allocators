The evaluation of the adapted allocators presents considerable challenges. Because these allocators are not integrated into ZGC, definitive conclusions regarding their performance are difficult to reach. Only proxy benchmarks are possible, serving as indicators of potential performance. Isolating the allocators for testing removes the influence of ZGC or other user-defined logic. This isolation can result in, for example, cache-locality effects that do not accurately reflect real-world scenarios. However, these assessments enable a comparison of the allocators on a uniformly defined basis and allow for a discussion of their comparative effectiveness.

Performance and external fragmentation benchmarks demonstrate that the binary tree allocator consistently outperforms the binary buddy allocator, but at the cost of increased memory overhead. Furthermore, the iBuddy allocator exhibits significant differences in allocation performance and external fragmentation distribution compared to the other two allocators. The choice of an allocator for a particular scenario should depend on the most critical performance metric for that use case.

Internal fragmentation is the most significant issue faced by all the allocators. The requirement to round up block sizes leads to considerable waste, especially with larger allocations. Since most allocations do not align with a perfect power of two, fragmentation occurs with each allocation, diminishing the efficiency of any buddy allocator in utilizing memory space. In the context of ZGC, this problem can be mitigated by strategically grouping object allocations to minimize internal fragmentation. Further discussion of this strategy is found in Section~\ref{sec:futureworkZ} as future work.

External fragmentation can only be measured empirically, which is why the allocation/deallocation pattern is chosen to induce significant fragmentation without maximizing it. Under this pattern, all allocator versions experience high external fragmentation, particularly at larger block sizes, where most of the total space is located. This suggests that failures predominantly occur with very large allocation requests and that a wide range of allocation sizes presents a major weakness, increasing the likelihood of failures for large requests. Limiting the range of sizes would likely decrease external fragmentation. Consequently, within ZGC, it should be presumed that additional allocatable space exists even if an allocation attempt fails. Assuming that memory is fully utilized could lead to considerable memory wastage.

\newpage
The unique behavior of the iBuddy allocator is evident in the benchmarks. Notably, its performance for large block allocations is significantly worse compared with small allocations in the other two allocators. Its only advantage is a slight increase in speed at the smallest allocation sizes. However, its strategy of aggressively splitting blocks quickly inhibits the allocation of larger blocks. Therefore, the iBuddy allocator is only feasible when nearly all allocations are among the smallest sizes. If a considerable number of allocations exceed this size, there will be a notable decrease in both performance and usable memory.

Considering all factors, the binary tree allocator emerges as the most promising option for implementation in ZGC among the three discussed. It consistently outperforms the binary buddy allocator in all benchmarks, while the iBuddy allocator is impractical due to the reasons discussed. Since memory consumption is not a critical concern, the additional memory expense of the binary tree allocator is justified by its speed improvement. Although the binary tree allocator is slower at smaller allocation sizes, this drawback can be mitigated by using the lazy layer, keeping good performance across all allocation sizes. This configuration is deemed the most promising for integrating a buddy allocator within ZGC.

However, the intrinsic weaknesses of buddy allocators remain. Internal fragmentation will be significant, even if it is possible to reduce it. Blocks still need to be aligned to their size, which could become problematic if previous memory is awkwardly placed. In addition, the cost of frequent allocator initialization could become non-negligible. These issues should be taken into account when integrating with ZGC, as they could affect both performance and memory efficiency. Future work should focus on strategies to mitigate these weaknesses and explore alternative allocation algorithms that may offer improved performance and reduced fragmentation in the context of ZGC.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
